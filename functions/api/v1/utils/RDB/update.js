import getRDB from './getRDB';

/**
 * this function will update an object to a DB path without overwriting other children in collection
 * @param {string} path - string that represents database collection path
 * @param {object} data - object to update
 * @param {object} opts - an object with additional options to write:
 *  {string} child - any child path
 *  {boolean} autoKey - true to add autogenerated key to the path; otherwise false;
 *    if child value contains {autoKey} placeholder, it will be replaced by autogenerated key; otherwise the key will be added in a tail
 *  {string} error - error message to be thrown if writing to RDB is launched in async mode
 */
const update = async (path, data, opts) => {
  const RDB = getRDB();
  let ref = RDB.ref(path);

  if (opts) {
    let childPath = opts.child;

    // add autoKey
    if (opts.autoKey) {
      const key = ref.push().key;
      if (childPath) {
        if (childPath.includes('autoKey')) {
          // see https://www.designcise.com/web/tutorial/how-to-fix-replaceall-is-not-a-function-javascript-error
          childPath = childPath.replace(/{autoKey}/g, key);
        } else {
          childPath = `${childPath}/${key}`;
        }
      } else {
        ref = ref.child(key);
      }
    }

    // add child path
    if (childPath) {
      ref = ref.child(childPath);
    }

    // async call with predefined error message
    if (opts.error) {
      ref.update(data, (error) => {
        // error - equals to null or undefined if everything is ok here...
        if (error) {
          throw new Error(opts.error);
        }
      });
    }
  }

  // sync call (usual behaviour)
  if (!opts?.error) {
    await ref.update(data);
  }
};

export default update;
